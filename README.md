This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

Реалізація переходів між сторінками через React Router
  1.1  Встановлення React Router
Спочатку була встановлена бібліотека React Router, що дозволяє управляти навігацією в односторінкових додатках (SPA). Це необхідно для забезпечення плавних переходів між різними компонентами без перезавантаження сторінки.
 1.2 Налаштування Router
У головному файлі додатку був імплементований BrowserRouter, що обертає весь додаток. Це дозволяє використовувати компоненти маршрутизації на всіх сторінках, надаючи можливість визначати, які компоненти мають відображатися для конкретних шляхів.
1.3 Створення маршрутів
Для кожної сторінки в додатку були визначені маршрути, вказуючи шлях, який відповідає конкретному компоненту. Це означає, що для кожного маршруту було визначено, який контент буде відображатися.
1.4 Навігація між сторінками
Для переходу між сторінками використовувався компонент Link, що дозволяє користувачам натискати на посилання і переходити на інші маршрути без перезавантаження. Це забезпечує зручність і швидкість навігації.
1.5 Навігація на основі подій
У випадках, коли необхідно було переходити за подіями (наприклад, після натискання кнопки), застосовувався хук useNavigate. Це дозволяє програмно переходити на інші сторінки в додатку, зберігаючи при цьому контекст.
1.6 Передача параметрів у маршрутах
Для передачі даних між сторінками (наприклад, ідентифікатора користувача для редагування) використовувалися параметри в URL. Це дає можливість передавати інформацію про конкретні об'єкти між компонентами.

Створення AppRouter.tsx для роботи з React Router
 2.1 Створення компонента AppRouter
Розробка основної структури компонента, що обертає всі маршрути у проекті. Це забезпечує централізовану точку управління маршрутизацією, що дозволяє підтримувати чистоту та організованість коду.
2.2 Використання BrowserRouter
Інтеграція BrowserRouter з бібліотеки react-router-dom, яка дозволяє реалізувати односторінковий додаток з динамічною зміною URL без перезавантаження сторінки. Це робить навігацію між сторінками швидкою та безшовною, покращуючи користувацький досвід.
2.3 Передача дочірніх елементів
Реалізація механізму передачі дочірніх компонентів через пропс children. Це дозволяє користувачеві вказувати, які компоненти будуть відображатися в межах маршруту, роблячи AppRouter більш універсальним та гнучким. Дочірні компоненти можуть бути будь-якими — від простих сторінок до складних інтерфейсів.
2.4 Забезпечення безпеки для дочірніх компонентів
Гарантування того, що дочірні компоненти будуть рендеритись лише в контексті маршрутизації. Це означає, що весь додаток отримає доступ до функцій маршрутизації, таких як зміна URL, доступ до історії навігації та інформації про активний маршрут.
2.5 Взаємодія з Router
Створення можливості для налаштування маршрутів у подальшому використанні AppRouter. Наприклад, розробник може легко додавати нові маршрути, які ведуть на різні сторінки, не змінюючи основну структуру AppRouter. Це значно полегшує підтримку та масштабування проекту.
2.6 Масштабованість
AppRouter забезпечує базу для організації маршрутизації в розширених проектах. Коли проект зростає, додавання нових компонентів та маршрутів стає простішим, оскільки структура маршрутизації залишається централізованою.


2.7 Тестування та дебаг
Завдяки чіткій структурі AppRouter, тестування маршрутизації та дебаг додатку стає зручнішим. Розробники можуть легко перевіряти маршрути без впливу на інші частини додатку, що підвищує ефективність розробки.
Декомпозована створення компоненту App Routes
3.1 Створення компонента AppRoutes
Розробка нового компонента, який відповідає за визначення маршрутизації у додатку. Це дозволяє централізовано керувати навігацією між різними сторінками, що спрощує структуру додатку.
3.2 Використання Routes та Route з react-router-dom
Інтеграція компонентів Routes та Route для створення набору маршрутів. Це дає можливість визначити, які компоненти будуть відображатися на кожному конкретному маршруті, зберігаючи організованість коду та легкість в обслуговуванні.
3.3 Налаштування маршруту за замовчуванням
Реалізація маршруту за замовчуванням, який перенаправляє користувача з кореневої адреси ("/") на сторінку редагування користувача ("/edit-user"). Це зручно для користувача, оскільки він одразу потрапляє на початкову сторінку без додаткових дій.
3.4 Оголошення маршрутів для різних сторінок
Визначення маршрутів для сторінок редагування користувача (EditUserPage) та списку користувачів (UsersPage). Це дозволяє легко додавати нові маршрути у майбутньому, якщо з'явиться необхідність у нових функціональних можливостях.
3.5 Забезпечення чіткої навігації
Створення чіткої та зрозумілої навігаційної структури, що допомагає користувачам швидко орієнтуватися в додатку. Кожен маршрут надає доступ до відповідного компонента, що підвищує зручність використання.
3.6 Перенаправлення на існуючі маршрути
Використання компонента Navigate для автоматичного перенаправлення на певний маршрут. Це забезпечує більш плавний досвід користувача, дозволяючи уникнути зайвих дій.
Створення компоненту Button
4.1 Створення компонента Button
Розробка універсального компонента кнопки, який можна використовувати в різних частинах додатку. Це дозволяє централізувати стилі та функціональність кнопок, що спрощує їх обслуговування та забезпечує узгодженість у дизайні.
4.2 Визначення типів пропсів
Створення типу ButtonProps, що включає властивості, які можуть передаватися компоненту, такі як label, isActive, isDisabled, width, та onClick. Це дозволяє налаштовувати поведінку та вигляд кнопки відповідно до потреб конкретної ситуації.
4.3 Обробка станів кнопки
Реалізація логіки для обробки різних станів кнопки:
isActive: Зміна стилю кнопки для візуального відображення активного стану. Це дозволяє користувачам бачити, яка кнопка активна або вибрана.
isDisabled: Зміна стилю кнопки, коли вона вимкнена, і блокування можливості натискання. Це важливо для запобігання несанкціонованих дій.
4.4 Налаштування стилів
Додавання стилів для кнопки, що базуються на її стані. Кнопка має різні кольори фону та тексту для активного, неактивного та вимкнутого станів. Це підвищує зрозумілість інтерфейсу та покращує користувацький досвід.
4.5 Кастомізація ширини кнопки
Додавання властивості width для кастомізації ширини кнопки. Це дозволяє легко налаштувати розміри кнопки в залежності від контексту, в якому вона використовується.
4.6 Обробка події натискання
Використання функції onClick для обробки події натискання на кнопку. Це дозволяє інтегрувати кнопку в логіку програми, активуючи відповідні дії, коли кнопка натискається.



Створення компонента Button Icon
5.1 Створення верстки кнопки з іконкою:
Реалізація базової структури компонента, що включає в себе HTML-розмітку для кнопки або посилання.
Включення зображення іконки за допомогою тегу <img>.
5.2 Додання пропсів для конфігурації:
Використання пропсів для гнучкого налаштування компоненту, таких як iconSrc, isActive, isDisabled, width, onClick, і href.
Визначення типів пропсів за допомогою TypeScript для підвищення безпеки типів.
5.3 Управління стилями кнопки:
Застосування умовного рендерингу для зміни класів CSS на основі стану (активний/неактивний) кнопки.
Використання Tailwind CSS класів для стилізації кнопки з врахуванням активного/неактивного стану.
5.4 Обробка подій:
Додавання функціональності для обробки кліків по кнопці або посиланню через пропс onClick.
Додаткова логіка для блокування кліків, коли кнопка неактивна.
5.5 Підтримка посилань:
Додавання можливості передавати URL через пропс href, щоб перетворити кнопку в посилання, якщо це необхідно.
5.6 Гнучкість у розміщенні:
Використання пропсу width для визначення ширини кнопки, що дозволяє легко адаптувати компонент під різні макети.





	
Створення компонента Dropdown
6.1 Створення верстки для випадаючого списку:
Реалізація базової структури компонента, що включає в себе HTML-розмітку для кнопки та списку опцій.
Використання CSS-класів для стилізації елементів, таких як кнопка та контейнер для списку.
6.2 Додання пропсів для налаштування:
Включення пропсів, таких як options, width, selectedValue, та onSelect для гнучкого управління компонентом.
Використання TypeScript для визначення типів пропсів, що підвищує безпеку та зрозумілість коду.
6.3 Управління станом відкриття випадаючого списку:
Застосування хука useState для відстеження стану відкриття списку (включено/виключено).
Обробка подій кліку на кнопку для відкриття та закриття списку.
6.4 Вибір опції:
Використання функції onSelect, що передається через пропси, для управління вибором значення.
Закриття випадаючого списку після вибору опції.
6.5 Показ вибраного значення:
Показ вибраного значення (або підказки) на кнопці.
Визначення логіки для перевірки, чи вибрана опція, і відображення її назви.
 



 


 
Створення компонента Dropdown Element
7.1 Створення верстки для елемента списку:
Розробка HTML-структури для компонента, що включає контейнер, заголовок та поле для вибору (checkbox).
Використання CSS-класів для стилізації елемента списку, щоб надати йому привабливий вигляд.
7.2 Додавання пропсів для налаштування:
Включення пропсів, таких як label, isSelected, та onToggle для налаштування функціональності компонента.
Використання TypeScript для визначення типів пропсів, що підвищує безпеку і читаємість коду.
7.3 Управління вибором:
Обробка події кліку на контейнері для виклику функції onToggle, що забезпечує зміну стану вибору.
Встановлення стану вибору через пропс isSelected, що дозволяє компоненту динамічно відображати, чи обрана опція.
7.4 Створення checkbox для відображення вибору:
Додавання checkbox, який відображає стан вибору опції.
Забезпечення того, що checkbox є недоступним для редагування, але відображає обране значення.
Створення компонента Dropdown Selected
8.1 Створення верстки для компонента DropdownSelected:
Розроблено основну структуру компонента, що включає поле вводу для вибору опцій і список для відображення доступних опцій.
Використано CSS класи для стилізації компонента, щоб надати йому привабливий вигляд і зручність використання.
8.2 Додавання пропсів для налаштування:
Включено пропси, такі як options, width, selectedValues та onSelect, що дозволяють налаштувати поведінку та зовнішній вигляд компонента.
Використано TypeScript для визначення типів пропсів, що підвищує безпеку та читаємість коду.

8.3 Управління відкриттям/закриттям списку опцій:
Додано обробник подій для натискання на компонент, що перемикає видимість списку опцій.
Збережено стан видимості списку у локальному стані за допомогою useState.
8.4 Фільтрація опцій на основі введеного тексту:
Реалізовано механізм фільтрації, який дозволяє користувачу шукати опції в списку на основі введеного тексту.
Використано функцію filter для відбору опцій, що відповідають введеному запиту.
8.5 Обробка вибору опцій:
Реалізовано функцію handleOptionSelect, що дозволяє додавати або видаляти опції з масиву вибраних значень.
Виклик функції onSelect з оновленим масивом вибраних значень, що дозволяє батьківському компоненту отримувати актуальні дані про вибір.
Створення компонента Filter
9.1 Створення структури компонента Filter:
Розроблено основний шаблон компонента, що містить три секції для фільтрації: департаменти, країни та статуси.
Використано CSS класи для стилізації компоненту, що забезпечує зручний інтерфейс.
9.2 Визначення типів пропсів:
Включено пропси для департаментів, країн, статусів та функції для обробки змін фільтра.
Використано TypeScript для створення чіткої типізації, що підвищує безпеку та читаємість коду.
9.3 Управління станом вибору:
Додано локальний стан для зберігання вибраних значень департаментів, країн та статусів за допомогою useState.
Реалізовано функцію handleFilterChange, яка викликає функцію onFilterChange, передаючи обрані значення.
	  

9.4 Очищення фільтрів:
Реалізовано функцію clearFilters, яка скидає всі вибрані фільтри до початкового стану та викликає handleFilterChange, щоб повідомити батьківський компонент про скидання.
9.5 Взаємодія з дочірніми компонентами:
Додано компонент DropdownSelected для вибору декількох департаментів, що дозволяє користувачу вибирати кілька опцій одночасно.
Використано компонент Dropdown для вибору країн та статусів, що дозволяє користувачу вибрати одне значення з відповідних списків.
Створення компонента Header
10.1 Створення базової структури заголовка:
Розроблено основну верстку компонента заголовка (Header), що включає навігаційне меню з двома посиланнями: "Edit Users" та "Users".
Використано Flexbox для вирівнювання елементів у заголовку, що дозволяє легко адаптувати його під різні розміри екрану.
10.2 Використання React Router для навігації:
Інтегровано Link з react-router-dom для реалізації навігації між сторінками, що дозволяє змінювати URL без перезавантаження сторінки.
Додано обробку активних посилань за допомогою useLocation, що дозволяє відслідковувати поточний шлях у навігації.
10.3 Управління станом активної сторінки:
Використано локальний стан activePage для зберігання інформації про поточну сторінку.
Реалізовано useEffect, який слідкує за змінами location.pathname і оновлює стан активної сторінки, що дозволяє динамічно змінювати стиль активного посилання.
10.4 Стилізація навігаційних посилань:
Додано стилі для активного і неактивного станів посилань, що підвищує зручність використання і візуальну привабливість.
Використано CSS класи для налаштування кольору фону, кольору тексту та інших візуальних характеристик, таких як ефект при наведенні.


Створення компонента AddUser Popup
11.1 Створення верстки попапу: Розроблено інтерфейс для попапу, що з'являється на екрані для додавання нового користувача. Попап містить форму з полями для введення інформації про користувача.
11.2 Створення полів для введення даних: Реалізовані текстові поля для введення повного імені, вибору департаменту, країни та статусу користувача.
11.3 Підтягування даних: Вибір департаменту, країни та статусу реалізовано через випадаючі списки, які отримують дані з JSON-файлів (departments.json, countries.json, statuses.json). Це дозволяє динамічно заповнювати випадаючі списки.
11.4 Обробка змін у полях: Додано обробники подій, які оновлюють стан локальних змінних (fullName, selectedDepartment, selectedCountry, selectedStatus) відповідно до введених даних.
11.5 Логіка додавання користувача: Реалізовано функцію handleAddUser, яка сповіщає про успішне додавання користувача через alert. Цю функцію можна вдосконалити, додавши логіку для збереження даних на сервер або у базу даних.
11.6 Закриття попапу: Додано кнопку "Cancel" для закриття попапу без внесення змін, а також кнопка "Add Users", яка викликає функцію для обробки додавання користувача.
11.7 Структура макету: Використано CSS-класи для стилізації попапу та його елементів, щоб забезпечити приємний і зрозумілий інтерфейс для користувача. Попап з'являється з затемненням фону, щоб зосередити увагу на формі.


Декомпозований  компонента (сторінки) edit user
12.1 Імпорт необхідних залежностей: На початку компонента імпортуються необхідні бібліотеки та компоненти, такі як React, хуки useState і useEffect, а також компоненти Dropdown, Input і Button. Також імпортуються дані з JSON-файлів, які містять інформацію про користувачів, країни, департаменти та статуси.


12.2 Створення масивів опцій для випадаючих списків:
userOptions: Генерується масив об'єктів для користувачів, що містять ім'я та значення (значення є іменем користувача).
countryOptions, departmentOptions, statusOptions: Для кожної з цих категорій також створюються масиви, що містять імена та значення, з якими будуть працювати випадаючі списки.
12.3 Створення стану для компоненту:
users: Стан для зберігання інформації про користувачів.
selectedUser: Стан для зберігання вибраного користувача.
fullName, selectedCountry, selectedDepartment, selectedStatus: Стан для зберігання значень, які користувач може редагувати.
initialData: Стан для зберігання початкових даних обраного користувача.
isModified: Стан, що вказує, чи були внесені зміни.
12.4 Підтягування даних обраного користувача:
Використовується useEffect, щоб знайти обраного користувача у масиві users і ініціалізувати стани для редагування на основі його даних. Це дозволяє заповнити поля вводу даними обраного користувача.
12.5 Перевірка на внесення змін:
Другий useEffect використовується для перевірки, чи були внесені зміни до полів. Якщо дані у полях не збігаються з початковими даними, isModified буде встановлено в true, що сигналізує про внесення змін.
12.6 Функція скидання змін:
handleUndo скидає поля вводу до значень початкових даних, що було витягнуто раніше. Якщо дані не змінилися, ця функція просто скидає значення полів на їх початкові значення.
12.7 Функція збереження змін:
onSave відповідає за обробку збереження внесених змін. Вона створює новий масив updatedUsers, де оновлює дані обраного користувача. Після цього виконується запит на сервер для збереження змін. Якщо запит успішний, масив users оновлюється, і користувач отримує підтвердження про успішне збереження.
12.8 Структура верстки:
Використовується JSX для формування інтерфейсу компонента. Включає заголовок, поле для вибору користувача (випадковий список), поля вводу для редагування даних, а також кнопки "Undo" і "Save".
Поля вводу та випадаючі списки мають зрозумілі етикетки, що покращує зручність використання інтерфейсу.
Декомпозований  компонента (сторінки) user
13.1Імпорт необхідних залежностей: Спочатку імпортуються необхідні компоненти та дані, такі як Filter, AddUserPopup, Button, ButtonIcon, а також дані з JSON-файлів для користувачів, країн, департаментів і статусів. Це дозволяє використовувати їх у компоненті.
13.2 Створення стану:
isPopupVisible: Стан для контролю видимості попапу додавання нового користувача.
filteredData: Стан для зберігання даних користувачів, які відповідають критеріям фільтрації.
departmentsOptions, countriesOptions, statusesOptions: Стан для зберігання опцій для фільтрації за департаментами, країнами та статусами.
selectedDepartments, selectedCountries, selectedStatus: Стан для зберігання вибраних фільтрів.
13.3 Завантаження опцій для фільтрів:
Використовується useEffect, щоб підготувати масиви опцій для кожного з фільтрів (департаменти, країни та статуси). Данні з JSON-файлів перетворюються в формат, зручний для використання у випадаючих списках.
13.4 Фільтрація користувачів:
Інший useEffect перевіряє, чи були обрані департаменти, країни та статуси, а потім фільтрує дані користувачів відповідно до вибраних критеріїв. Відфільтровані дані оновлюють стан filteredData.
13.5 Відкриття та закриття попапу:
handleOpenPopup: Функція для відкриття попапу при натисканні на кнопку "Add User".
handleClosePopup: Функція для закриття попапу.


13.6 Обробка змін фільтрів:
handleFilterChange: Функція, що оновлює вибрані значення для департаментів, країн і статусів, які потім передаються до батьківського компонента для фільтрації.
13.7 Видалення користувача:
handleDeleteUser: Функція для видалення користувача з таблиці. Вона фільтрує масив filteredData і оновлює його, видаляючи користувача з вказаним ім'ям.
13.8 Структура верстки:
Включає заголовок, фільтр, кнопку для відкриття попапу та таблицю, що відображає інформацію про користувачів. Створена таблиця має стовпці для імені, департаменту, країни, статусу та дій (з кнопкою для видалення).
13.9 Таблиця з можливістю прокрутки:
Таблиця обгорнута в контейнер з максимальним висотою, що дозволяє користувачеві прокручувати дані, якщо їх занадто багато для відображення на екрані.


